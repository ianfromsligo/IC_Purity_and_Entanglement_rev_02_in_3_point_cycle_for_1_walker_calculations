# -*- coding: utf-8 -*-
"""Two Coins 1 walker experiment 01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PkpEsPHkRF-B9ySY7cT2ULSNJQKtXNxx
"""

"""
Quantum Walk on 3-Cycle: Verification Code
Ian Craig, 27th January 2026
"""

import numpy as np

def quantum_walk_3cycle(rho, alpha=0, beta=0, steps=8):
    """
    Simulate quantum walk on 3-cycle with given coin parameters.

    Parameters:
    -----------
    rho : float
        Coin parameter (0 <= rho <= 1)
    alpha, beta : float
        Phase parameters
    steps : int
        Number of steps to simulate

    Returns:
    --------
    dict with results
    """

    # 1. SETUP
    k = 3  # 3-cycle
    basis = [(c, x) for x in range(k) for c in range(2)]  # |c,x⟩, c changes fastest

    # 2. BUILD COIN OPERATOR C = I_k ⊗ C2
    C2 = np.array([
        [np.sqrt(rho), np.sqrt(1-rho)*np.exp(1j*alpha)],
        [np.sqrt(1-rho)*np.exp(1j*beta), -np.sqrt(rho)*np.exp(1j*(alpha+beta))]
    ], dtype=complex)

    C = np.zeros((6, 6), dtype=complex)
    for i, (c1, x1) in enumerate(basis):
        for j, (c2, x2) in enumerate(basis):
            if x1 == x2:  # I_k part
                C[i, j] = C2[c1, c2]

    # 3. BUILD SHIFT OPERATOR S
    S = np.zeros((6, 6), dtype=complex)
    for j, (c, x) in enumerate(basis):
        if c == 0:
            x_new = (x - 1) % k  # counterclockwise
        else:
            x_new = (x + 1) % k  # clockwise
        i = basis.index((c, x_new))
        S[i, j] = 1

    # 4. FULL STEP OPERATOR U = S·C
    U = S @ C

    # 5. INITIAL STATE |ψ₀⟩ = |0,0⟩
    psi0 = np.zeros(6, dtype=complex)
    psi0[0] = 1  # |0,0⟩

    # 6. EVOLUTION
    psi_list = [psi0.copy()]
    for step in range(1, steps + 1):
        psi_list.append(U @ psi_list[-1])

    # 7. CALCULATE METRICS
    results = {
        'rho': rho,
        'alpha': alpha,
        'beta': beta,
        'U': U,
        'psi_list': psi_list,
        'probabilities': [],
        'purities': [],
        'entropies': []
    }

    for step, psi in enumerate(psi_list):
        # Position probabilities
        prob = np.zeros(k)
        for x in range(k):
            prob[x] = abs(psi[2*x])**2 + abs(psi[2*x+1])**2
        results['probabilities'].append(prob)

        # Purity γ = Tr(ρ²)
        rho_full = np.outer(psi, psi.conj())
        purity = np.trace(rho_full @ rho_full).real
        results['purities'].append(purity)

        # Reduced coin density matrix
        rho_coin = np.zeros((2, 2), dtype=complex)
        for c1 in range(2):
            for c2 in range(2):
                rho_coin[c1, c2] = sum(psi[2*x + c1] * psi[2*x + c2].conj()
                                       for x in range(k))

        # Eigenvalues and von Neumann entropy
        eigvals = np.linalg.eigvalsh(rho_coin)
        eigvals = np.maximum(eigvals, 0)  # Remove tiny negatives
        entropy = -sum(v * np.log2(v) for v in eigvals if v > 1e-12)
        results['entropies'].append(entropy.real)

    return results

def print_results(results, coin_name=""):
    """Print formatted results."""
    print(f"\n{'='*60}")
    print(f"{coin_name} (ρ = {results['rho']:.4f})")
    print('='*60)

    print("\nStep | P(0)    P(1)    P(2)    | Purity γ  | Entropy S (bits)")
    print("-" * 65)

    for step in range(len(results['psi_list'])):
        prob = results['probabilities'][step]
        purity = results['purities'][step]
        entropy = results['entropies'][step]

        print(f"{step:4} | {prob[0]:.4f}   {prob[1]:.4f}   {prob[2]:.4f}   | {purity:.6f}  | {entropy:.6f}")

def verify_revival(results, steps=8):
    """Check if revival occurs within given steps."""
    psi0 = results['psi_list'][0]
    for step, psi in enumerate(results['psi_list'][1:], 1):
        if np.allclose(psi, psi0, atol=1e-10):
            return step
    return None

# MAIN VERIFICATION
if __name__ == "__main__":
    print("QUANTUM WALK ON 3-CYCLE: VERIFICATION")
    print("="*60)

    # 1. Hadamard coin (ρ = 1/2)
    hadamard = quantum_walk_3cycle(rho=0.5, steps=8)
    print_results(hadamard, "Hadamard Coin")
    revival_step = verify_revival(hadamard)
    print(f"\nRevival period: {revival_step if revival_step else 'None found (up to step 8)'}")

    # 2. Dukes' revival coin (ρ = 2/3)
    revival = quantum_walk_3cycle(rho=2/3, steps=8)
    print_results(revival, "Dukes' Revival Coin")
    revival_step = verify_revival(revival)
    print(f"\nRevival period: {revival_step if revival_step else 'None found (up to step 8)'}")

    # 3. Additional verification: Check U⁸ for revival coin
    print("\n" + "="*60)
    print("ADDITIONAL VERIFICATION")
    print("="*60)

    U = revival['U']
    U8 = np.linalg.matrix_power(U, 8)
    is_identity = np.allclose(U8, np.eye(6), atol=1e-10)
    print(f"For ρ = 2/3: U⁸ = I? {is_identity}")
    print(f"Max deviation from identity: {np.max(np.abs(U8 - np.eye(6))):.2e}")

    # 4. Check probability sums
    print("\nProbability sum verification (should be 1.0000):")
    for coin_name, results in [("Hadamard", hadamard), ("Revival", revival)]:
        print(f"\n{coin_name}:")
        for step, prob in enumerate(results['probabilities']):
            print(f"  Step {step}: Sum = {sum(prob):.6f}")

    # 5. Check purity (should be 1.0000)
    print("\nPurity verification (should be 1.0000):")
    for coin_name, results in [("Hadamard", hadamard), ("Revival", revival)]:
        print(f"\n{coin_name}:")
        for step, purity in enumerate(results['purities']):
            print(f"  Step {step}: γ = {purity:.6f}")